<!DOCTYPE html>
<html>

<head>
	<title>Arbmageddon</title>
	<script type="text/javascript" src="vis.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue-resource@1.3.5"></script>
	<link href="vis.css" rel="stylesheet" type="text/css" />
	<link rel='stylesheet' href='/stylesheets/style.css' />
	<style type="text/css">
		.app-container {
			position: absolute;
			top: 0px;
			bottom: 0px;
			left: 0px;
			right: 0px;
			background-color: black;
			color: white;
		}

		.flex-row {
			display: flex;
			/* or inline-flex */
			flex-direction: row;
		}

		.flex-col {
			display: flex;
			/* or inline-flex */
			flex-direction: column;
			/* height: 100%; */
		}

		.flex-grow {
			flex-grow: 1;
			/* default 0 */
		}

		.flex-wrap {
			flex-wrap: wrap;
		}

		.flex-stretch {
			align-items: stretch;
		}

		.flex-center {
			align-items: center;
		}

		.flex-start {
			align-items: flex-start;
		}

		.flex-justify {
			justify-content: space-around;
		}

		.arb-list {
			overflow-y: auto;
		}

		.operation {
			margin: 5px;
			padding: 5px;
		}

		.spread {
			border: solid;
			border-width: 2px;
			border-color: white;
			color: white;
		}

		.selected {
			background-color: aqua;
			color: black;
		}

		.buy-convert-op {
			border: solid;
			border-width: 2px;
			border-color: greenyellow;
			color: greenyellow;
		}

		.buy-op {
			border: solid;
			border-width: 2px;
			border-color: aqua;
			color: aqua;
		}

		.sell-op {
			border: solid;
			border-width: 2px;
			border-color: red;
			color: red;
		}

		.sell-convert-op {
			border: solid;
			border-width: 2px;
			border-color: orange;
			color: orange;
		}

		.center-contents {
			align-content: center;
		}

		.op-title {
			text-align: center;
		}

		.arb-good {
			color: greenyellow;
		}

		.arb-bad {
			color: red;
		}

		.arb-neutral {
			border: solid;
			border-width: 2px;
			border-color: white;
			color: white;
		}

		.full-width {
			width: 100%;
		}

		.elbow-room>* {
			margin: 2px;
			padding: 2px;
		}
	</style>
	<script type="text/x-template" id="operation-template">
		<div class="flex-col elbow-room ">
			<div class="center-contents">
				<strong v-if="side === 'buy'">{{ title }}: [{{ operation.exchange }}] {{ operation.market }} / {{ operation.hub }}</strong>
				<strong v-else>{{ title }}: [{{ operation.exchange }}] {{ operation.market }} / {{ operation.hub }}</strong>
			</div>
			<div class="flex-grow flex-row flex-wrap flex-stretch">
				<div class="flex-grow">
					<span>VWAP</span>
					<span>{{ operation.price.toFixed(8) }}</span>
				</div>
			</div>
			<div class="flex-grow flex-row flex-wrap flex-stretch">
				<div class="flex-grow">
					<span>Market Size: </span>
					<span>{{ operation.size.toFixed(8) }}</span>
				</div>
				<div class="flex-grow">
					<span>Hub Size: </span>
					<span>{{ operation.hubSize.toFixed(8) }}</span>
				</div>
				<div class="flex-grow">
					<span>Basis Size: </span>
					<span>{{ operation.basisSize.toFixed(8) }}</span>
				</div>
			</div>
			<div class="flex-grow flex-row flex-wrap flex-stretch">
				<div class="flex-grow">
					<span>Hub Position</span>
					<span>{{ operation.position }}</span>
				</div>
				<div class="flex-grow">
					<span>Market Position</span>
					<span>{{ operation.position }}</span>
				</div>
				<div class="flex-grow">
					<span>Basis Position</span>
					<span>{{ operation.position }}</span>
				</div>
			</div>
			<button>Execute!</button>
		</div>
	</script>
</head>

<body>
	<div id="app-dash" class="app-container flex-col elbow-room">
		<div>
			<div class="flex-row flex-stretch elbow-room">
				<execution-component v-if="selectedSpread && selectedSpread.type === 1" side="buy" class="buy-convert-op flex-grow" title="Buy Convert"
				 :operation="selectedSpread.convert"></execution-component>
				<execution-component v-if="selectedSpread" side="buy" class="buy-op flex-grow" title="Buy" :operation="selectedSpread ? selectedSpread.buy : null"></execution-component>
				<execution-component v-if="selectedSpread" side="sell" class="sell-op flex-grow" title="Sell" :operation="selectedSpread ? selectedSpread.sell: null"></execution-component>
				<execution-component v-if="selectedSpread && selectedSpread.type === 2" side="sell" class="sell-convert-op flex-grow" title="Sell Convert"
				 :operation="selectedSpread.convert"></execution-component>
			</div>
		</div>
		<div>
			<div v-if="selectedSpread" class="spread elbow-room flex-row flex-justify">
				<div>
					<strong>Arb: {{ selectedSpread.id }}</strong>
				</div>
				<div v-bind:class="{ 'arb-good': arbIsGood(selectedSpread), 'arb-bad': !arbIsGood(selectedSpread) }">
					<strong>Spreads Per Minute: {{ selectedSpread.spreadsPerMinute }}</strong>
				</div>
				<div v-bind:class="{ 'arb-good': arbIsGood(selectedSpread), 'arb-bad': !arbIsGood(selectedSpread) }">
					<strong>Basis Per Minute: {{ (selectedSpread.spreadsPerMinute * selectedSpread.spread).toFixed(4) }}</strong>
				</div>
			</div>
			<div class="flex-row flex-justify">
				<div class="flex-col flex-start">
					<span>Arb Types:</span>
					<div>
						<input type="checkbox" id="direct-checkbox" value="false" v-model="showDirect">
						<label for="direct-checkbox">Direct</label>
					</div>
					<div>
						<input type="checkbox" id="conversion-checkbox" value="true" v-model="showConversion">
						<label for="conversion-checkbox">Conversion</label>
					</div>
				</div>
				<div class="flex-col flex-start">
					<span>On Chain:</span>
					<div>
						<input type="checkbox" id="cross-exchange-checkbox" value="false" v-model="showCrossExchange">
						<label for="cross-exchange-checkbox">Cross Exchange</label>
					</div>
					<div>
						<input type="checkbox" id="same-exchange-checkbox" value="true" v-model="showSameExchange">
						<label for="same-exchange-checkbox">Same Exchange</label>
					</div>
				</div>
				<div class="flex-col flex-start">
					<span>Pricing:</span>
					<div>
						<input type="radio" id="taker" value="1" v-model="initiationType">
						<label for="taker">Taker</label>
					</div>
					<div>
						<input type="radio" id="maker" value="0" v-model="initiationType">
						<label for="maker">Maker</label>
					</div>
				</div>
				<div class="flex-col flex-start">
					<div>
						<span>Basis Size (BTC): </span>
						<input v-model="basisSize" type="number" min="0" max="10" step="0.1">
					</div>
					<div>
						<span>Spread Target (%): </span>
						<input v-model="spreadTarget" type="number" min="2" max="20" step="0.5">
					</div>
				</div>
			</div>
		</div>
		<div class="flex-row flex-grow">
			<div class="flex-col elbow-room">
				<div class="flex-grow arb-list">
					<table>
						<thead>
							<th>Arb</th>
							<th>Basis</th>
							<th>Hub</th>
							<th>%</th>
							<th>SPM</th>
							<th>HPM</th>
							<th>BPM</th>
						</thead>
						<tbody>
							<tr v-for="spread in getFilteredArbs(arbList)" v-on:click="setMulticharts(spread)" v-bind:class="{ selected: spread.selected }">
								<td>{{ spread.id }}</td>
								<td>{{ (spread.spread).toFixed(4) }}</td>
								<td>{{ (spread.hubSpread).toFixed(4) }}</td>
								<td>{{ (spread.spreadPercent * 100).toFixed(2) }}</td>
								<td>{{ spread.spreadsPerMinute }}</td>
								<td>{{ (spread.spreadsPerMinute * spread.hubSpread).toFixed(4) }}</td>
								<td>{{ (spread.spreadsPerMinute * spread.spread).toFixed(4) }}</td>
							</tr>
						</tbody>
					</table>
				</div>
			</div>
			<div class="flex-grow">
				<iframe :src="multichartsUrl" height="100%" width="100%"></iframe>
			</div>
		</div>
	</div>
	<script>
		let exchMap = {};
		const arbMap = {};
		let updateCount = 0;
		let validUpdateCount = 0;
		const ws = new WebSocket('ws://localhost:8080/');
		const getCoinigySymbol = (op) => {
			return `${exchMap[op.exchange]}:${op.market}${op.hub}`;
		}
		const getMccQueryString = (spread) => {
			if (spread) {
				const buy = getCoinigySymbol(spread.buy);
				const sell = getCoinigySymbol(spread.sell);
				if (spread.type === 0) { // Buy Spread
					return `?chart=${buy}&chart=${sell}&chart=${sell}-${buy}`;
				} else { // Conversion
					const convert = getCoinigySymbol(spread.convert);
					if (spread.type === 1) { // Origin Conversion
						return `?chart=${buy}&chart=${sell}&chart=${convert}&chart=${sell}-${buy}*${convert}`;
					} else if (spread.type === 2) { // Destination Conversion
						return `?chart=${buy}&chart=${sell}&chart=${convert}&chart=${sell}*${convert}-${buy}`;
					} else {
						return null;
					}
				}
			}
		}
		Vue.component('execution-component', {
			template: '#operation-template',
			props: ['title', 'side', 'operation']
		});
		const props = {
			basisSize: 0.05,
			spreadTarget: 0.5,
			initiationType: 0
		};
		const appDash = new Vue({
			el: '#app-dash',
			data: {
				exchanges: [],
				arbList: [],
				// arbMap: [],
				selectedSpread: undefined,
				multichartsUrl: 'https://www.multicoincharts.com/?chart=ETHBTC&chart=XRPETH&chart=XRPBTC&chart=XRPBTC/XRPETH-ETHBTC',
				showCrossExchange: false,
				showSameExchange: true,
				showDirect: true,
				showConversion: true,
				symbolFilter: 'SYM',
				basisSize: props.basisSize,
				spreadTarget: props.spreadTarget,
				initiationType: props.initiationType,
				graphProperties: props
			},
			watch: {
				basisSize: (newBasis, oldBasis) => {
					const basis = parseFloat(newBasis);
					if (!Number.isNaN(basis)) {
						appDash.graphProperties.basisSize = basis;
						appDash.updateGraphProperties();
					}
				},
				spreadTarget: (newTarget, oldTarget) => {
					const target = parseFloat(newTarget);
					if (!Number.isNaN(target)) {
						appDash.graphProperties.spreadTarget = target;
						appDash.updateGraphProperties();
					}
				},
				initiationType: (newType, oldType) => {
					const type = parseInt(newType);
					appDash.graphProperties.initiationType = type;
					appDash.updateGraphProperties();
				}
			},
			methods: {
				updateGraphProperties: () => {
					ws.send(JSON.stringify({
						to: 'graph',
						from: 'gui',
						action: 'set',
						type: 'params',
						data: appDash.graphProperties
					}));
				},
				getExchanges: () => {
					return new Promise((resolve, reject) => {
						Vue.http.get('/graph/exchanges').then(response => {
							appDash.exchanges = response.body;
							exchMap = appDash.exchanges.reduce((map, exch) => {
								// map[exch.id] = exch.name;
								map[exch.name] = exch.id;
								return map;
							}, {});
							resolve();
						}, response => {
							reject();
						});
					});
				},
				getFilteredArbs: () => {
					if (appDash) {
						return appDash.arbList.filter((spread) => {
							const isCrossExchange = spread.buy.exchange !== spread.sell.exchange;
							const crossExchangePasses = appDash.showCrossExchange === isCrossExchange;
							const isDirect = spread.type === 0;
							const directPasses = appDash.showDirect === isDirect;
							const isConversion = spread.type !== 0;
							const conversionPasses = appDash.showConversion === isConversion;
							// const spreadPasses = Number.parseFloat(appDash.spreadFilter) / 100 < spread.spread;
							// return (crossExchangePasses || directPasses || conversionPasses) && spreadPasses;
							return crossExchangePasses || directPasses || conversionPasses;
						}).slice(0, 25);
					} else {
						return [];
					}
				},
				arbIsGood(spread) {
					if (spread) {
						return 0 < spread.timeAboveTarget && spread.sumOfDurations < spread.timeAboveTarget;
					} else {
						return false;
					}
				},
				setMulticharts: (spread) => {
					if (spread) {
						const queryString = getMccQueryString(spread);
						appDash.multichartsUrl = `https://www.multicoincharts.com/${queryString}`;
						spread.selected = true;
						if (appDash.selectedSpread && appDash.selectedSpread.selected) {
							appDash.selectedSpread.selected = false;
						}
						appDash.selectedSpread = spread;
					}
				},
				setup: () => {
					appDash
						.getExchanges()
						.then(() => {
							return appDash.setupWebsocket();
						})
						.then(() => {
							appDash.sortLoop();
						});
				},
				sortLoop: () => {
					appDash.arbList.sort((a, b) => {
						return b.spread - a.spread;
					});
					setTimeout(appDash.sortLoop, 1000);
				},
				updateArb: (update) => {
					updateCount++;
					if (update.spread) {
						validUpdateCount++;
						if (validUpdateCount % 10 === 0) {
							console.log(`Update Count: Spread=${validUpdateCount}, No Spread=${updateCount}`);
						}
						const arb = arbMap[update.id];
						if (arb) {
							const target = appDash.graphProperties.spreadTarget;
							if (arb.spread < target && target < update.spread) {
								arb.spreadEnteredAt = Date.now();
							}
							arb.timeAboveTarget = Date.now() - arb.spreadEnteredAt;
							arb.spread = update.spread;
							arb.spreadPercent = update.spreadPercent;
							arb.spreadsPerMinute = update.spreadsPerMinute;
							arb.buy.price = update.buy.price;
							arb.buy.duration = update.buy.duration;
							arb.buy.size = update.buy.size;
							arb.buy.hubSize = update.buy.hubSize;
							arb.buy.basisSize = update.buy.basisSize;
							arb.sell.price = update.sell.price;
							arb.sell.duration = update.sell.duration;
							arb.sell.size = update.sell.size;
							arb.sell.hubSize = update.sell.hubSize;
							arb.sell.basisSize = update.sell.basisSize;
							if (arb.convert) {
								arb.convert.price = update.convert.price;
								arb.convert.duration = update.convert.duration;
								arb.convert.size = update.convert.size;
								arb.convert.hubSize = update.convert.hubSize;
								arb.convert.basisSize = update.convert.basisSize;
								arb.sumOfDurations =
									update.buy.duration +
									update.sell.duration +
									update.convert.duration;
							} else {
								arb.sumOfDurations =
									update.buy.duration +
									update.sell.duration;
							}
						} else {

							update.spreadEnteredAt = Date.now();
							arbMap[update.id] = update;
							appDash.arbList.push(update);
						}
						if (!appDash.selectedSpread) {
							appDash.setMulticharts(appDash.arbList[0]);
						}
					} else {
						// Only update selected spread:
					}
				},
				setupWebsocket: () => {
					return new Promise((resolve, reject) => {
						ws.onclose = () => {
							console.log('Application Websocket closed.');
							setTimeout(appDash.setupWebsocket, 1000);
						};

						ws.onmessage = (message) => {
							const msg = JSON.parse(message.data);
							if (msg.to === 'gui' && msg.from === 'graph') {
								if (msg.type === 'arb' && msg.action === 'update') {
									appDash.updateArb(msg.data);
								} else if (msg.type === 'params' && msg.action === 'set') {
									appDash.graphProperties = msg.data;
								}
							}
						};

						ws.onopen = () => {
							console.log('App Websocket opened.');
							ws.send(JSON.stringify({
								to: 'graph',
								from: 'gui',
								type: 'params',
								action: 'get'
							}));
							console.log('Graph params requested.');
						};

						// it's the least you could do!
						window.onbeforeunload = () => {
							ws.close();
						};

						resolve();
					});
				}
			}
		});
		appDash.setup();
	</script>
</body>

</html>