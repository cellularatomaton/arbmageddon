<!DOCTYPE html>
<html>

<head>
	<title>Arbmageddon</title>
	<script type="text/javascript" src="vis.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue-resource@1.3.5"></script>
	<link href="vis.css" rel="stylesheet" type="text/css" />
	<link rel='stylesheet' href='/stylesheets/style.css' />
	<style type="text/css">
		.app-container {
			position: absolute;
			top: 0px;
			bottom: 0px;
			left: 0px;
			right: 0px;
			background-color: black;
			color: white;
		}

		.flex-row {
			display: flex;
			/* or inline-flex */
			flex-direction: row;
		}

		.flex-col {
			display: flex;
			/* or inline-flex */
			flex-direction: column;
			/* height: 100%; */
		}

		.flex-grow {
			flex-grow: 1;
			/* default 0 */
		}

		.flex-wrap {
			flex-wrap: wrap;
		}

		.flex-stretch {
			align-items: stretch;
		}

		.flex-center {
			align-items: center;
		}

		.flex-start {
			align-items: flex-start;
		}

		.flex-justify {
			justify-content: space-around;
		}

		.arb-list {
			overflow-y: auto;
		}

		.operation {
			margin: 5px;
			padding: 5px;
		}

		.selected {
			background-color: aqua;
		}

		.buy-convert-op {
			border: solid;
			border-width: 2px;
			border-color: greenyellow;
			color: greenyellow;
		}

		.buy-op {
			border: solid;
			border-width: 2px;
			border-color: aqua;
			color: aqua;
		}

		.sell-op {
			border: solid;
			border-width: 2px;
			border-color: red;
			color: red;
		}

		.sell-convert-op {
			border: solid;
			border-width: 2px;
			border-color: orange;
			color: orange;
		}

		.center-contents {
			align-content: center;
		}

		.op-title {
			text-align: center;
		}

		.arb-good {
			color: greenyellow;
		}

		.arb-bad {
			color: red;
		}

		.arb-neutral {
			border: solid;
			border-width: 2px;
			border-color: white;
			color: white;
		}

		.full-width {
			width: 100%;
		}

		.elbow-room>* {
			margin: 2px;
			padding: 2px;
		}
	</style>
	<script type="text/x-template" id="operation-template">
        <div class="flex-col elbow-room ">
            <div class="center-contents">
                <strong v-if="side === 'buy'">{{ title }}: [{{ operation.exchange }}] {{ operation.hub }} -> {{ operation.market }}</strong>
                <strong v-else>{{ title }}: [{{ operation.exchange }}] {{ operation.market }} -> {{ operation.hub }}</strong>
            </div>
            <div class="flex-grow flex-row flex-wrap flex-stretch">
                <div class="flex-grow">
                    <span>VWAP</span>
                    <span>{{ operation.price.toFixed(8) }}</span>
                </div>
                <div class="flex-grow">
                    <span>Duration</span>
                    <span>{{ (operation.duration/1000).toFixed(0) }}</span>
                </div>
                <div class="flex-grow">
                    <span>Position</span>
                    <span>{{ operation.position }}</span>
                </div>
            </div>
            <div class="flex-grow flex-row flex-wrap flex-stretch">
                <div class="flex-grow">
                    <span>Open Bids</span>
                    <span>{{ operation.openBids }}</span>
                </div>
                <div class="flex-grow">
                    <span>Open Asks</span>
                    <span>{{ operation.openAsks }}</span>
                </div>
            </div>
            <button>Execute!</button>
        </div>
    </script>
</head>

<body>
	<div id="app-dash" class="app-container flex-col elbow-room">
		<div>
			<div class="flex-row flex-stretch elbow-room">
				<execution-component v-if="selectedInst && selectedInst.type === 1" side="buy" class="buy-convert-op flex-grow" title="Buy Convert"
				 :operation="selectedInst.convert"></execution-component>
				<execution-component v-if="selectedInst" side="buy" class="buy-op flex-grow" title="Buy" :operation="selectedInst ? selectedInst.buy : null"></execution-component>
				<execution-component v-if="selectedInst" side="sell" class="sell-op flex-grow" title="Sell" :operation="selectedInst ? selectedInst.sell: null"></execution-component>
				<execution-component v-if="selectedInst && selectedInst.type === 2" side="sell" class="sell-convert-op flex-grow" title="Sell Convert"
				 :operation="selectedInst.convert"></execution-component>
			</div>
		</div>
		<div>
			<div class="flex-row flex-justify">
				<div class="flex-col flex-start">
					<span>Arb Types:</span>
					<div>
						<input type="checkbox" id="direct-checkbox" value="false" v-model="showDirect">
						<label for="direct-checkbox">Direct</label>
					</div>
					<div>
						<input type="checkbox" id="conversion-checkbox" value="true" v-model="showConversion">
						<label for="conversion-checkbox">Conversion</label>
					</div>
				</div>
				<div class="flex-col flex-start">
					<span>On Chain:</span>
					<div>
						<input type="checkbox" id="cross-exchange-checkbox" value="false" v-model="showCrossExchange">
						<label for="cross-exchange-checkbox">Cross Exchange</label>
					</div>
					<div>
						<input type="checkbox" id="same-exchange-checkbox" value="true" v-model="showSameExchange">
						<label for="same-exchange-checkbox">Same Exchange</label>
					</div>
				</div>
				<div class="flex-col flex-start">
					<span>Pricing:</span>
					<div>
						<input type="radio" id="taker" value="1" v-model="initiationType">
						<label for="taker">Taker</label>
					</div>
					<div>
						<input type="radio" id="maker" value="0" v-model="initiationType">
						<label for="maker">Maker</label>
					</div>
				</div>
				<div class="flex-col flex-start" v-bind:class="{ 'arb-good': arbIsGood(selectedInst), 'arb-bad': !arbIsGood(selectedInst) }">
					<strong>Time Above Target: {{ (selectedInst.timeAboveTarget/1000).toFixed(0) }} s</strong>
					<strong>Execution Time: {{ (selectedInst.sumOfDurations/1000).toFixed(0) }} s</strong>
				</div>
				<div class="flex-col flex-start">
					<div>
						<span>Basis Size (BTC): </span>
						<input v-model="basisSize" type="number" min="0" max="10" step="0.1" placeholder="0.1">
					</div>
					<div>
						<span>Spread Target (%): </span>
						<input v-model="spreadTarget" type="number" min="2" max="20" step="0.5" placeholder="3.5">
					</div>
				</div>
			</div>
		</div>
		<div class="flex-row flex-grow">
			<div class="flex-col elbow-room">
				<div class="flex-grow arb-list">
					<table>
						<thead>
							<th>Arb</th>
							<th>Spread</th>
							<th>TAT</th>
							<th>SOD</th>
						</thead>
						<tbody>
							<tr v-for="inst in getFilteredArbs(arbList)">
								<td>{{ inst.id }}</td>
								<td>
									<button v-on:click="setMulticharts(inst)" v-bind:class="{ selected: inst.selected }">{{ instSpread(inst) }}</button>
								</td>
								<td v-bind:class="{ 'arb-good': arbIsGood(inst), 'arb-bad': !arbIsGood(inst) }">{{ (inst.timeAboveTarget/1000).toFixed(0) }}</td>
								<td v-bind:class="{ 'arb-good': arbIsGood(inst), 'arb-bad': !arbIsGood(inst) }">{{ (inst.sumOfDurations/1000).toFixed(0) }}</td>
							</tr>
						</tbody>
					</table>
				</div>
			</div>
			<div class="flex-grow">
				<iframe :src="multichartsUrl" height="100%" width="100%"></iframe>
			</div>
		</div>
	</div>
	<script>
		let exchMap = {};
		const arbMap = {};
		const ws = new WebSocket('ws://localhost:8080/');
		const getCoinigySymbol = (op) => {
			return `${exchMap[op.exchange]}:${op.market}${op.hub}`;
		}
		const getMccQueryString = (inst) => {
			if (inst) {
				const buy = getCoinigySymbol(inst.buy);
				const sell = getCoinigySymbol(inst.sell);
				if (inst.type === 0) { // Buy Spread
					return `?chart=${buy}&chart=${sell}&chart=${sell}-${buy}`;
				} else { // Conversion
					const convert = getCoinigySymbol(inst.convert);
					if (inst.type === 1) { // Origin Conversion
						return `?chart=${buy}&chart=${sell}&chart=${convert}&chart=${sell}-${buy}*${convert}`;
					} else if (inst.type === 2) { // Destination Conversion
						return `?chart=${buy}&chart=${sell}&chart=${convert}&chart=${sell}*${convert}-${buy}`;
					} else {
						return null;
					}
				}
			}
		}
		const opSymbolMatch = (symbol, op) => {
			return op.exchange.startsWith(symbol) ||
				op.hub.startsWith(symbol) ||
				op.market.startsWith(symbol);
		}
		const instSymbolMatch = (symbol, inst) => {
			const convertMatch = inst.convert ? opSymbolMatch(symbol, inst.convert) : false;
			return convertMatch ||
				opSymbolMatch(symbol, inst.buy) ||
				opSymbolMatch(symbol, inst.sell);
		}
		Vue.component('execution-component', {
			template: '#operation-template',
			props: ['title', 'side', 'operation']
		});
		const props = {
			basisSize: 0.1,
			spreadProperties: 5.0,
			initiationType: 0
		};
		const appDash = new Vue({
			el: '#app-dash',
			data: {
				exchanges: [],
				arbList: [],
				// arbMap: [],
				selectedInst: undefined,
				multichartsUrl: 'https://www.multicoincharts.com/?chart=ETHBTC&chart=XRPETH&chart=XRPBTC&chart=XRPBTC/XRPETH-ETHBTC',
				showCrossExchange: false,
				showSameExchange: true,
				showDirect: false,
				showConversion: true,
				symbolFilter: 'SYM',
				basisSize: props.basisSize,
				spreadTarget: props.spreadTarget,
				initiationType: props.initiationType,
				graphProperties: props
			},
			watch: {
				basisSize: (newBasis, oldBasis) => {
					const basis = parseFloat(newBasis);
					if (!Number.isNaN(basis)) {
						appDash.graphProperties.basisSize = basis;
						appDash.updateGraphProperties();
					}
				},
				spreadTarget: (newTarget, oldTarget) => {
					const target = parseFloat(newTarget);
					if (!Number.isNaN(target)) {
						appDash.graphProperties.spreadTarget = target;
						appDash.updateGraphProperties();
					}
				},
				initiationType: (newType, oldType) => {
					const type = parseInt(newType);
					appDash.graphProperties.initiationType = type;
					appDash.updateGraphProperties();
				}
			},
			methods: {
				updateGraphProperties: () => {
					ws.send(JSON.stringify({
						to: 'graph',
						from: 'gui',
						action: 'set',
						type: 'params',
						data: appDash.graphProperties
					}));
				},
				getExchanges: () => {
					return new Promise((resolve, reject) => {
						Vue.http.get('/graph/exchanges').then(response => {
							appDash.exchanges = response.body;
							exchMap = appDash.exchanges.reduce((map, exch) => {
								map[exch.id] = exch.name;
								return map;
							}, {});
							resolve();
						}, response => {
							reject();
						});
					});
				},
				getFilteredArbs: () => {
					return appDash.arbList.filter((inst) => {
						const isCrossExchange = inst.buy.exchange !== inst.sell.exchange;
						const crossExchangePasses = appDash.showCrossExchange === isCrossExchange;
						const isDirect = inst.type === 0;
						const directPasses = appDash.showDirect === isDirect;
						const isConversion = inst.type !== 0;
						const conversionPasses = appDash.showConversion === isConversion;
						// const spreadPasses = Number.parseFloat(appDash.spreadFilter) / 100 < inst.spread;
						// return (crossExchangePasses || directPasses || conversionPasses) && spreadPasses;
						return crossExchangePasses && directPasses && conversionPasses;
					}).slice(0, 20);
				},
				arbIsGood(inst) {
					if (inst) {
						return 0 < inst.timeAboveTarget && inst.sumOfDurations < inst.timeAboveTarget;
					} else {
						return false;
					}
				},
				instSpread: (i) => { return `${(i.spread * 100).toFixed(2)}%`; },
				instString: (inst) => {
					return getInstString(inst);
				},
				setMulticharts: (inst) => {
					if (inst) {
						const queryString = getMccQueryString(inst);
						appDash.multichartsUrl = `https://www.multicoincharts.com/${queryString}`;
						inst.selected = true;
						if (appDash.selectedInst && appDash.selectedInst.selected) {
							appDash.selectedInst.selected = false;
						}
						appDash.selectedInst = inst;
					}
				},
				setup: () => {
					appDash
						.getExchanges()
						.then(() => {
							return appDash.setupWebsocket();
						})
						.then(() => {
							appDash.sortLoop();
						});
				},
				sortLoop: () => {
					appDash.arbList.sort((a, b) => {
						return b.spread - a.spread;
					});
					setTimeout(appDash.sortLoop, 1000);
				},
				updateArb: (update) => {
					const arb = arbMap[update.id];
					if (arb) {
						const target = appDash.graphProperties.spreadTarget / 100;
						if (arb.spread < target && target < update.spread) {
							arb.spreadEnteredAt = Date.now();
						}
						arb.timeAboveTarget = Date.now() - arb.spreadEnteredAt;
						arb.spread = update.spread;
						arb.buy.price = update.buy.price;
						arb.buy.duration = update.buy.duration;
						arb.sell.price = update.sell.price;
						arb.sell.duration = update.sell.duration;
						if (arb.convert) {
							arb.convert.price = update.convert.price;
							arb.convert.duration = update.convert.duration;
							arb.sumOfDurations =
								update.buy.duration +
								update.sell.duration +
								update.convert.duration;
						} else {
							arb.sumOfDurations =
								update.buy.duration +
								update.sell.duration;
						}

					} else {
						update.spreadEnteredAt = Date.now();
						arbMap[update.id] = update;
						appDash.arbList.push(update);
					}
					if (!appDash.selectedInst) {
						appDash.setMulticharts(appDash.arbList[0]);
					}
				},
				setupWebsocket: () => {
					return new Promise((resolve, reject) => {
						ws.onclose = () => {
							console.log('Application Websocket closed.');
							setTimeout(appDash.setupWebsocket, 1000);
						};

						ws.onmessage = (message) => {
							const msg = JSON.parse(message.data);
							if (msg.to === 'gui' && msg.from === 'graph') {
								if (msg.type === 'arb' && msg.action === 'update') {
									appDash.updateArb(msg.data);
								} else if (msg.type === 'params' && msg.action === 'set') {
									appDash.graphProperties = msg.data;
								}
							}
						};

						ws.onopen = () => {
							console.log('App Websocket opened.');
							ws.send(JSON.stringify({
								to: 'graph',
								from: 'gui',
								type: 'params',
								action: 'get'
							}));
							console.log('Graph params requested.');
						};

						// it's the least you could do!
						window.onbeforeunload = () => {
							ws.close();
						};

						resolve();
					});
				}
			}
		});
		appDash.setup();
	</script>
</body>

</html>