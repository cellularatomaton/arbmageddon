<!DOCTYPE html>
<html>

<head>
	<title>Arbmageddon</title>
	<script type="text/javascript" src="vis.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue"></script>
	<script src="https://cdn.jsdelivr.net/npm/vue-resource@1.3.5"></script>
	<link href="vis.css" rel="stylesheet" type="text/css" />
	<link rel='stylesheet' href='/stylesheets/style.css' />
	<style type="text/css">
		.app-container {
			position: absolute;
			top: 0px;
			bottom: 0px;
			left: 0px;
			right: 0px;
			background-color: black;
			color: white;
		}

		.flex-row {
			display: flex;
			/* or inline-flex */
			flex-direction: row;
		}

		.flex-col {
			display: flex;
			/* or inline-flex */
			flex-direction: column;
			/* height: 100%; */
		}

		.flex-grow {
			flex-grow: 1;
			/* default 0 */
		}

		.flex-wrap {
			flex-wrap: wrap;
		}

		.flex-stretch {
			align-items: stretch;
		}

		.flex-center {
			align-items: center;
		}

		.flex-start {
			align-items: flex-start;
		}

		.flex-justify {
			justify-content: space-around;
		}

		.arb-list {
			overflow-y: auto;
		}

		.operation {
			margin: 5px;
			padding: 5px;
		}

		.selected {
			background-color: aqua;
		}

		.buy-convert-op {
			border: solid;
			border-width: 2px;
			border-color: greenyellow;
			color: greenyellow;
		}

		.buy-op {
			border: solid;
			border-width: 2px;
			border-color: aqua;
			color: aqua;
		}

		.sell-op {
			border: solid;
			border-width: 2px;
			border-color: red;
			color: red;
		}

		.sell-convert-op {
			border: solid;
			border-width: 2px;
			border-color: orange;
			color: orange;
		}

		.center-contents {
			text-align: center;
			align-content: center;
		}

		.op-title {
			text-align: center;
		}

		.arb-good {
			color: greenyellow;
		}

		.arb-bad {
			color: red;
		}

		.arb-neutral {
			border: solid;
			border-width: 2px;
			border-color: white;
			color: white;
		}

		.full-width {
			width: 100%;
		}

		.elbow-room>* {
			margin: 2px;
			padding: 2px;
		}
	</style>
	<script type="text/x-template" id="operation-template">
        <div class="flex-col elbow-room ">
            <div>
                <h4 class="op-title" v-if="side === 'buy'">{{ title }}: [{{ operation.exchange }}] {{ operation.hub }} -> {{ operation.market }}</h4>
                <h4 class="op-title" v-else>{{ title }}: [{{ operation.exchange }}] {{ operation.market }} -> {{ operation.hub }}</h4>
            </div>
            <div class="flex-grow flex-row flex-wrap flex-stretch">
                <div class="flex-grow">
                    <span>VWAP</span>
                    <span>{{ operation.price.toFixed(8) }}</span>
                </div>
                <div class="flex-grow">
                    <span>Duration</span>
                    <span>{{ (operation.duration/1000).toFixed(0) }}</span>
                </div>
                <div class="flex-grow">
                    <span>Position</span>
                    <span>{{ operation.position }}</span>
                </div>
            </div>
            <div class="flex-grow flex-row flex-wrap flex-stretch">
                <div class="flex-grow">
                    <span>Open Bids</span>
                    <span>{{ operation.openBids }}</span>
                </div>
                <div class="flex-grow">
                    <span>Open Asks</span>
                    <span>{{ operation.openAsks }}</span>
                </div>
            </div>
            <button>Execute!</button>
        </div>
    </script>
</head>

<body>
	<div id="app-dash" class="app-container flex-col elbow-room">
		<div>
			<div class="flex-row flex-stretch elbow-room">
				<execution-component v-if="selectedInst && selectedInst.type === 1" side="buy" class="buy-convert-op flex-grow" title="Buy Convert"
				 :operation="selectedInst.convert"></execution-component>
				<execution-component v-if="selectedInst" side="buy" class="buy-op flex-grow" title="Buy" :operation="selectedInst ? selectedInst.buy : null"></execution-component>
				<execution-component v-if="selectedInst" side="sell" class="sell-op flex-grow" title="Sell" :operation="selectedInst ? selectedInst.sell: null"></execution-component>
				<execution-component v-if="selectedInst && selectedInst.type === 2" side="sell" class="sell-convert-op flex-grow" title="Sell Convert"
				 :operation="selectedInst.convert"></execution-component>
			</div>
		</div>
		<div>
			<div class="flex-row flex-center">
				<div class="flex-grow flex-col flex-start elbow-room">
					<span>Arb Types:</span>
					<div>
						<input type="checkbox" id="direct-checkbox" value="false" v-model="showDirect">
						<label for="direct-checkbox">Direct</label>
					</div>
					<div>
						<input type="checkbox" id="cross-exchange-checkbox" value="false" v-model="showCrossExchange">
						<label for="cross-exchange-checkbox">Cross Exchange</label>
					</div>
					<div>
						<input type="checkbox" id="conversion-checkbox" value="true" v-model="showConversion">
						<label for="conversion-checkbox">Conversion</label>
					</div>
				</div>
				<div class="flex-grow flex-col flex-start elbow-room">
					<span>Pricing:</span>
					<div>
						<input type="radio" id="taker" value="Taker" v-model="pricingMode">
						<label for="taker">Taker</label>
					</div>
					<div>
						<input type="radio" id="maker" value="Maker" v-model="pricingMode">
						<label for="maker">Maker</label>
					</div>
				</div>
				<div class="flex-grow flex-col flex-start elbow-room" v-bind:class="{ 'arb-good': arbIsGood(selectedInst), 'arb-bad': !arbIsGood(selectedInst) }">
					<strong>Time Above Target: {{ (selectedInst.timeAboveTarget/1000).toFixed(0) }} s</strong>
					<strong>Execution Time: {{ (selectedInst.sumOfDurations/1000).toFixed(0) }} s</strong>
				</div>
				<div class="flex-grow flex-col flex-start elbow-room">
					<div>
						<span>Basis Size (BTC): </span>
						<input v-model="basisSize" type="number" min="0" max="10" step="0.1" placeholder="0.1">
					</div>
					<div>
						<span>Spread Filter (%): </span>
						<input v-model="spreadFilter" type="number" min="2" max="20" step="0.5" placeholder="3.5">
					</div>
				</div>
			</div>
		</div>
		<div class="flex-row flex-grow">
			<div class="flex-col elbow-room">
				<div class="flex-grow arb-list">
					<table>
						<thead>
							<th>Arb</th>
							<th>Spread</th>
							<th>TAT</th>
							<th>SOD</th>
						</thead>
						<tbody>
							<tr v-for="inst in getFilteredArbs(arbList)">
								<td>{{ inst.id }}</td>
								<td>
									<button v-on:click="setMulticharts(inst)" v-bind:class="{ selected: inst.selected }">{{ instSpread(inst) }}</button>
								</td>
								<td v-bind:class="{ 'arb-good': arbIsGood(inst), 'arb-bad': !arbIsGood(inst) }">{{ (inst.timeAboveTarget/1000).toFixed(0) }}</td>
								<td v-bind:class="{ 'arb-good': arbIsGood(inst), 'arb-bad': !arbIsGood(inst) }">{{ (inst.sumOfDurations/1000).toFixed(0) }}</td>
							</tr>
						</tbody>
					</table>
				</div>
			</div>
			<div class="flex-grow">
				<iframe :src="multichartsUrl" height="100%" width="100%"></iframe>
			</div>
		</div>
	</div>
	<script>
		let exchMap = {};
		const arbMap = {};

		const getCoinigySymbol = function (op) {
			return `${exchMap[op.exchange]}:${op.market}${op.hub}`;
		}
		const getMccQueryString = function (inst) {
			if (inst) {
				const buy = getCoinigySymbol(inst.buy);
				const sell = getCoinigySymbol(inst.sell);
				if (inst.type === 0) { // Buy Spread
					return `?chart=${buy}&chart=${sell}&chart=${sell}-${buy}`;
				} else { // Conversion
					const convert = getCoinigySymbol(inst.convert);
					if (inst.type === 1) { // Origin Conversion
						return `?chart=${buy}&chart=${sell}&chart=${convert}&chart=${sell}-${buy}*${convert}`;
					} else if (inst.type === 2) { // Destination Conversion
						return `?chart=${buy}&chart=${sell}&chart=${convert}&chart=${sell}*${convert}-${buy}`;
					} else {
						return null;
					}
				}
			}
		}
		const opSymbolMatch = function (symbol, op) {
			return op.exchange.startsWith(symbol) ||
				op.hub.startsWith(symbol) ||
				op.market.startsWith(symbol);
		}
		const instSymbolMatch = function (symbol, inst) {
			const convertMatch = inst.convert ? opSymbolMatch(symbol, inst.convert) : false;
			return convertMatch ||
				opSymbolMatch(symbol, inst.buy) ||
				opSymbolMatch(symbol, inst.sell);
		}
		Vue.component('execution-component', {
			template: '#operation-template',
			props: ['title', 'side', 'operation']
		});
		const appDash = new Vue({
			el: '#app-dash',
			data: {
				exchanges: [],
				arbList: [],
				// arbMap: [],
				selectedInst: null,
				multichartsUrl: 'https://www.multicoincharts.com/?chart=ETHBTC&chart=XRPETH&chart=XRPBTC&chart=XRPBTC/XRPETH-ETHBTC',
				showCrossExchange: false,
				showDirect: false,
				showConversion: true,
				symbolFilter: 'SYM',
				spreadFilter: 5.0,
				basisSize: 0.1,
				pricingMode: 'Taker'
			},
			methods: {
				getExchanges: function () {
					return new Promise(function (resolve, reject) {
						Vue.http.get('/graph/exchanges').then(response => {
							appDash.exchanges = response.body;
							exchMap = appDash.exchanges.reduce(function (map, exch) {
								map[exch.id] = exch.name;
								return map;
							}, {});
							resolve();
						}, response => {
							reject();
						});
					});
				},
				getFilteredArbs: function () {
					return appDash.arbList.filter(function (inst) {
						const isCrossExchange = inst.buy.exchange !== inst.sell.exchange;
						const crossExchangePasses = appDash.showCrossExchange === isCrossExchange;
						const isDirect = inst.type === 0;
						const directPasses = appDash.showDirect === isDirect;
						const isConversion = inst.type !== 0;
						const conversionPasses = appDash.showConversion === isConversion;
						const spreadPasses = Number.parseFloat(appDash.spreadFilter) / 100 < inst.spread;
						return (crossExchangePasses || directPasses || conversionPasses) && spreadPasses;
					});
				},
				arbIsGood(inst) {
					return 0 < inst.timeAboveTarget && inst.sumOfDurations < inst.timeAboveTarget;
				},
				instSpread: function (i) { return `${(i.spread * 100).toFixed(2)}%`; },
				instString: function (inst) {
					return getInstString(inst);
				},
				setMulticharts: function (inst) {
					if (inst) {
						const queryString = getMccQueryString(inst);
						appDash.multichartsUrl = `https://www.multicoincharts.com/${queryString}`;
						inst.selected = true;
						if (appDash.selectedInst && appDash.selectedInst.selected) {
							appDash.selectedInst.selected = false;
						}
						appDash.selectedInst = inst;
					}
				},
				setup: function () {
					appDash
						.getExchanges()
						.then(function () {
							return appDash.setupWebsocket();
						})
						.then(appDash.sortLoop);
				},
				sortLoop: function () {
					appDash.arbList.sort((a, b) => {
						return b.spread - a.spread;
					});
					setTimeout(appDash.sortLoop, 1000);
				},
				setupWebsocket: function () {
					return new Promise(function (resolve, reject) {
						const ws = new WebSocket('ws://localhost:8080/');
						ws.addEventListener('message', function (message) {
							const msg = JSON.parse(message.data);
							if (msg.type === 'arb') { // Spread Update
								const update = msg.data;
								const instruction = arbMap[update.id];
								if (instruction) {
									const target = appDash.spreadFilter / 100;
									if (instruction.spread < target && target < update.spread) {
										instruction.spreadEnteredAt = Date.now();
									}
									instruction.timeAboveTarget = Date.now() - instruction.spreadEnteredAt;
									instruction.spread = update.spread;
									instruction.buy.price = update.buy.price;
									instruction.buy.duration = update.buy.duration;
									instruction.sell.price = update.sell.price;
									instruction.sell.duration = update.sell.duration;
									if (instruction.convert) {
										instruction.convert.price = update.convert.price;
										instruction.convert.duration = update.convert.duration;
										instruction.sumOfDurations =
											update.buy.duration +
											update.sell.duration +
											update.convert.duration;
									} else {
										instruction.sumOfDurations =
											update.buy.duration +
											update.sell.duration;
									}

								} else {
									update.spreadEnteredAt = Date.now();
									arbMap[update.id] = update;
									appDash.arbList.push(update);
								}
								if (!appDash.selectedInst) {
									appDash.setMulticharts(appDash.arbList[0]);
								}
							}
						});
						resolve();
					});
				}
			}
		});
		appDash.setup();
	</script>
</body>

</html>